<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Read Modify Write</title>
        <link>https://readmodifywrite.github.io/</link>
        <description></description>
        <language>en-us</language>
        <pubDate>Thu, 15 Dec 2016 00:00:00 -0600</pubDate>
        
        <item>
            <link>https://readmodifywrite.github.io/2016/12/15/2016_12_15_memory_alignment_esp8266.html</link>
            <guid>https://readmodifywrite.github.io/2016/12/15/2016_12_15_memory_alignment_esp8266.html</guid>
            <title><![CDATA[Memory alignment on ESP8266 - Exception(9)]]></title>
            <description><![CDATA[<h1>Memory alignment on ESP8266 - Exception(9)</h1>
<p>This one was tough to track down, but extremely obvious once I figured it out.  The ESP8266 has limitations on accessing data through a pointer.  Namely, 32 bit accesses need to be aligned on a 32 bit boundary, and 16 bit boundaries for a 16 bit access.</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">){</span>

    <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the lowest 2 bits of ptr (the actual address) are not zeroes, you get Exception (9).  This is easy to do if you have packed structs:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">struct</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">)){</span>
    <span class="kt">uint8_t</span> <span class="n">something</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">something_else</span><span class="p">;</span>
<span class="p">}</span> <span class="n">this_may_crash_t</span><span class="p">;</span>
</pre></div>
</div>
<p>If you pass a pointer from something_else to func, the compiler won’t know the pointer is unaligned and it cannot do anything about it.  So you need to manually make sure your access is aligned.  Simple, right?</p>
]]></description>
             <pubDate>Thu, 15 Dec 2016 00:00:00 -0600</pubDate>
        </item>
    
        <item>
            <link>https://readmodifywrite.github.io/2016/09/13/2016_09_13_avrdude_on_windows_10.html</link>
            <guid>https://readmodifywrite.github.io/2016/09/13/2016_09_13_avrdude_on_windows_10.html</guid>
            <title><![CDATA[AVRDude on Windows 10]]></title>
            <description><![CDATA[<h1>AVRDude on Windows 10</h1>
<p>Getting AVRDude to recognize a JTAG mk 2 on Windows 10:</p>
<p>Go <a class="reference external" href="https://sourceforge.net/projects/libusb-win32/files/libusb-win32-releases/1.2.6.0/">here</a></p>
<p>Install libusb-win32-devel-filter-1.2.6.0.exe</p>
<p>In the device filter set up, select the JTAG device. Done!</p>
]]></description>
             <pubDate>Tue, 13 Sep 2016 00:00:00 -0500</pubDate>
        </item>
    
        <item>
            <link>https://readmodifywrite.github.io/2016/09/12/2016_09_12_xmega_usart_txd_pin_reset.html</link>
            <guid>https://readmodifywrite.github.io/2016/09/12/2016_09_12_xmega_usart_txd_pin_reset.html</guid>
            <title><![CDATA[AVR Xmega USART TXD pin reset]]></title>
            <description><![CDATA[<h1>AVR Xmega USART TXD pin reset</h1>
<p>I found some undocumented behavior on the AVR Xmega A4U USART, and a <a class="reference external" href="http://blog.world3.net/2012/02/xmega-usart-unsets-output-direction-on-ports-when-disabling-tx/">helpful link from someone else who had the same issue.</a></p>
<p>If you enable the USART and then disable it (TXEN bit), the TXD pin reverts to an input. If you want to re-enable the USART later, you need to reconfigure the PORT.DIR register.</p>
<p>Probably not many people will run in to this, but in case you’re doing something fancy with your USART, there you go.</p>
]]></description>
             <pubDate>Mon, 12 Sep 2016 00:00:00 -0500</pubDate>
        </item>
    
    </channel>
</rss>